export let introduction = {
    "encryptDecode": [
        [{
            "title": "算法描述",
            "text": "明文中的所有字母在字母表中向后（或向前）按照一个固定数目进行偏移，形成密文。恺撒密码（Caesar cipher），或称恺撒加密、恺撒变换、变换加密，是一种最简单且最广为人知的加密技术，当年恺撒曾用此方法与其将军们进行联系，故此命名为恺撒密码。恺撒密码非常容易被破解，而且在实际应用中也无法保证通信安全。"
        }, {
            "title": "实现思路",
            "text": "获取明文字母的ASCII编码，将编码与密钥求和（解密时求差），（如果所求值不在字母的ASCII编码范围内，求模，使其重新回到字母编码范围），再依据ASCII表转换为字母。"
        }],
        [{
            "title": "算法描述",
            "text": "根据字母表，A与Z对应，B与Y对应，将明文中的字母依次替换。字母倒排序属于单字母替换加密方式中的一种，这种方式以每一个字母为一个加密单元，使用字母首位的对应关系加密，形成密文。这种方式同样很容被破解，无法保证通信安全。"
        }, {
            "title": "实现思路",
            "text": "获取明文的ASCII编码，所有对应的字母ASCII之和为定值（如‘A’+‘Z’=155，不同编码体系此值不同），用此定值减去明文字母得到ASCII编码，再转换成为字母求得密文。"
        }],
        [{
            "title": "算法描述",
            "text": "每一个密钥为一个加密单元，根据密钥形成新的字母对应关系，完成字母替换。单表置换是一种简易替换加密，此加密以特定方式改变字母表上字母顺序，并以此顺序书写的加密方式。利用密钥与二十六字母按顺序对应形成一张‘替换表’。利用“替换表”完成字母之间的替换，实现加密。"
        }, {
            "title": "实现思路",
            "text": "输入的密钥（去掉重复）按输入顺序与字母表中的字母一一对应，形成字母对应表，按此表实现字母之间的替换。"
        }],
        [{
            "title": "算法描述",
            "text": "将字母按从0到25进行编号，即字母A代表0，字母B代表1。将输入的密钥整体作为一个加密（解密）单元，输入密钥的长度为N，将N个字母（反复）依次与明文对应。将明文字母与密文字母所代表的数字求和，将所得和对26求模运算得到结果，此结果数字对应的字母就是加密后的密文字母。"
        }, {
            "title": "实现思路",
            "text": "字母从0到25编号，即字母A代表0，字母B代表1。输入密钥的长度为一个加密单元，将每个单元内的明文字母向后移动对应密钥字母所代表的位（解密时向前移），形成密文。"
        }],
        [{
            "title": "算法描述",
            "text": "根据输入密钥的长度n，形成n（密钥长度）列表格，将明文依次填入表格中，按特定的顺序输出，形成密文。转化法加密通过易位实现，易位按照一定的规则，重新安排明文中的比特或字符来形成密文，而字符本身保持不变。按易位的方式不同，可分为比特易位和字符易位两种，比特易位可利用硬件实现，主要运用于数字通信中；字符易位利用密钥对明文进行易位，形成密文。"
        }, {
            "title": "实现思路",
            "text": "获取密钥长度n，将明文按每行n（密钥长度）列字母进行填充，形成m（行）*n（列）表格。按列加密：根据字母在字母表中的顺序，按顺序输出字母所对应的列（如果输入的密钥是数字，则依次从前往后按列输出，效果与输入相同长度的单一字母一样，如密钥“5”与密钥“AAAAA”的加密效果一样），解密时使用逆操作，即将密文按字母顺序放入对应字母所对应的列，然后按行输出；按行加密：依次将每一行从后往前输出，形成密文。解密时使用逆操作。"
        }]
    ],
    "memoryPartition": [
        [{
            "title": "算法描述",
            "text": "每次为作业分配内存，将满足要求，又是最小的空闲分区分配给作业。"
        }, {
            "title": "算法特点",
            "text": "用最小的空间满足要求。此方法的优点是每次总是把最小的分区分配给作业，避免“大材小用”，缺点是每次分配后切割的剩余部分总是最小的，在存储器中留下许多难以利用的小空闲区。"
        }, {
            "title": "算法实现",
            "text": "将所有的空闲分区按容量从小到大形成一个空闲分区链，每次有作业请求时，按顺序遍历空闲分区，将第一个大于请求大小的空闲分区分配给该作业。"
        }],
        [{
            "title": "算法描述",
            "text": "每次为作业分配内存，将空闲分区表中一个不小于请求的最大空块分配给该内存。"
        }, {
            "title": "算法特点",
            "text": "当分割后空闲块仍为较大空块。此方法的优点是可使剩下的空闲区不至于太小，产生碎片的可能性最小；查找效率最高，将空闲区从大到小排序，只需要查找第一个分区就能够判断是否可满足作业要求。缺点是会使存储器中缺乏大的空闲分区"
        }, {
            "title": "算法实现",
            "text": "将所有的空闲分区按容量从大到小形成一个空闲分区链，每次有作业请求时，判断第一个空闲区是否满足请求的进程，如果满足，则将该分区分配给该进程。"
        }],
        [{
            "title": "算法描述",
            "text": "此算法要求空闲区域以地址递增的次序链接。分配内存时，从空闲链首开始顺序查找，直至找到一个大小能满足要求的空闲区为止。"
        }, {
            "title": "算法特点",
            "text": "优先利用内存中低址部分的空闲分区，保留高址部分的大空闲区。此算法的优点是优先使用低地址部分的空闲分区，从而保留了高地址部分的大空闲区，为以后到达的大作业分配空间创造了条件。缺点是低地址部分不断被划分，会留下许多难以利用的，很小的空闲分区，而每次查找时从低地址部分开始，会增加查找可用空闲分区的开销。"
        }, {
            "title": "算法实现",
            "text": "从头开始遍历空闲分区，找到第一个满足用户作业的内存块，分配给该作业。"
        }],
        [{
            "title": "算法描述",
            "text": "在分配内存空间时，不再每次从表头（链首）开始查找，而是从上次找到空闲区的下一个空闲开始查找，直到找到第一个能满足要求的的空闲区为止，并从中划出一块与请求大小相等的内存空间分配给作业。"
        }, {
            "title": "算法特点",
            "text": "内存均衡使用,减少了查询空闲分区时的开销。该算法优点是减少了查找内存分区时的开销，缺点是会使内存缺乏较大的空闲分区。"
        }, {
            "title": "算法实现",
            "text": "设置一起始查询指针，指示下一次起始查询的空闲分区（起始指针动态修改）,从指针所指位置开始往后查找，找到第一个满足用户作业的内存块，分配给该作业。"
        }]
    ],
    "processorSchedule": [
        [{
            "title": "算法描述",
            "text": "先来先服务总是把当前处于就绪队列之首的那个进程调度到运行状态，先进入系统的作业优先被挑选。也就说，先来先服务只考虑进程进入就绪队列的先后，而不考虑它的下一个CPU周期的长短及其他因素。"
        }, {
            "title": "算法特点",
            "text": "该算法优点是算法本身容易实现，适用于作业调度和进程调度；缺点是效率不高，只顾及作业等候时间，没考虑作业要求服务时间的长短，不利于短作业。FCFS算法在单处理机系统中已经很少作为。"
        }, {
            "title": "算法实现",
            "text": "遍历所有到达的进程，对其按照时间顺序排序，先来的进程先执行，后到的进程后执行，先来先服务不可以抢占，即先来先服务要求正在被执行的进程完成以后，才能够调度下一个进程被执行。  "
        }],
        [{
            "title": "算法描述",
            "text": "最短作业优先（SJF）以进入系统的作业所要求的CPU时间为标准，选取估计计算时间最短的作业投入运行。"
        }, {
            "title": "算法特点",
            "text": "该算法优点是算法本身容易实现，适用于作业调度和进程调度，能够有效的降低作业的平均等待时间；缺点是忽视了作业等待时间，对长作业不利，有可能导致长作业长期不被调度（饥饿现象），同时要精确知道一个作业的运行时间是很困难的。"
        }, {
            "title": "算法实现",
            "text": "首先执行第一个到达的作业，然后选取第一个作业执行过程中到达的要求时间最短的作业，接下来执行在第二个作业运行结束到达的所有作业（包括第一个作业运行中到达的作业）中要求最短的作业，如此往复，直至所有作业得到满足。"
        }],
        [{
            "title": "算法描述",
            "text": "最短剩余时间优先算法（SRTF）是将最短作业优先算法（SJF）改为剥夺式调度的一种算法。系统在每一个单位时间调度进程前，会比较所有进程剩余时间，并选取最短剩余时间的进程作为本次执行的进程。"
        }, {
            "title": "算法特点",
            "text": "SRTF算法相较于SJF算法，其全部进程的平均等待时间得到了降低，但是由于其剥夺式调度的特点，在进程切换的过程中或造成系统资源的浪费。若存在频繁切换的情况，会造成系统性能下降。"
        }, {
            "title": "算法实现",
            "text": "在系统的的每一个单位时间进行进程调度之前，对已到达的进程剩余时间进行排序，选取剩余时间最短的进程进行调度。在本次单位时间的调度结束之后，重复上述过程，选择调度已到达且剩余时间最短的进程，直至全部进程调度完毕。"
        }],
        [{
            "title": "算法描述",
            "text": "令优先权为作业等待的时间t与要求服务的时间r的和除以要求服务的时间，即（t+r）/r，该算法选取响应比最高的作业优先执行。如果作业的等待时间相同，则要求服务的时间越短，优先权越高，类似于SJF算法，有利于短作业；如果作业要求服务的时间相同，则作业的等待时间越长，其优先权越高，类似于FCFS算法。"
        }, {
            "title": "算法特点",
            "text": "该算法的优点是综合考虑作业的等待时间和运行时间，同时适用于作业调度和进程调度，既照顾短作业又不使长作业的等待时间过长。该算法的缺点是每次进项调度之前都需要进行响应比的计算，会增加系统开销。"
        }, {
            "title": "算法实现",
            "text": "首先执行第一个到达的进程，然后计算在第一个进程运行的时间内到达的所有进程的响应比，选取响应比最高的作业执行，然后计算在第二个作业运行结束到达的所有作业（包括第一个作业运行中到达的作业）的响应比，选取最高的执行，如此往复，直至所有作业得到满足。"
        }],
        [{
            "title": "算法描述",
            "text": "时间片轮转算法（RR）将所有的进程按FCFS策略排成一个就绪队列。系统每隔一段时间（如30ms）便产生一次中断，去激活进程调度程序进行调度，并把CPU分给队首进程，令其执行一段时间，执行的这一段时间被称为“时间片”。当这一个进程执行完后，又把处理机分配给队列中新的队首进程，让其得到执行。如此往复，使就绪队列中的所有进程在确定的时间段内，都能获得一个时间片的处理时间。"
        }, {
            "title": "算法特点",
            "text": "通过算法描述不难看出，时间片的大小对该算法的结果有很大影响。若时间片较小，则有利于短作业，因为它能在该时间片内完成；若时间片较大，则每一个进程都能在一个时间片内完成，时间片轮转算法退化为FCFS算法。时间片轮转算法主要针对分时系统，其优点是适用于进程调度，对用户的响应及时，迅速；缺点是时间片长度的确定比较困难，进程切换的开销比较大。"
        }, {
            "title": "算法实现",
            "text": "设定一时间片，对每个进程只执行时间片长度的时间。如果一个时间片尚未用完，正在运行的进程便已经完成，则将其从就绪队列中剔除，再调度就绪队列中队首的进程进行运行，并启动一个新的时间片；如果一个时间片用完，正在执行的进程没有执行完成，则停止执行该进程，将其放入就绪队列的末尾，执行就绪队列中的队首进程，并启动一个新的时间片。"
        }]
    ],
    "diskSchedule": [
        [{
            "title": "算法特点",
            "text": "先来先服务（FCFS）磁盘调度算法是最简单的磁盘调度算法，它根据进程请求访问磁盘的先后次序进行调度。此算法的有点是公平、简单，且每个进程的请求都能依次地得到处理，不会出现某一进程的请求长期得不到满足的情况。此种算法的弊端在于未对寻道次序进行优化，使得平均寻道时间可能较长，故FCFS算法一般仅适用于去请求磁盘I/O的进程数目较少的场合。"
        }, {
            "title": "算法实现",
            "text": "先来先服务（FCFS）算法不考虑其他因素，只考虑访问序列的先后顺序，因此在FCFS算法中，首先要对请求者（进程号）按其发出请求的先后次序排序，然后按照队列排好的先后顺序，从前往后，依次调入内存。"
        }],
        [{
            "title": "算法特点",
            "text": "最短寻道时间优先（SSTF）磁盘调度算法要求系统每一次寻找距离当前磁头所在磁道位置最近的请求（磁道），并访问该磁道，使得每次的寻道时间最短。在一般情况下，SSTF算法平均每次的寻道距离明显小于FCFS算法的距离，故相较之拥有更好的性能，在过去曾一度被广泛使用。然而，因其实质上是基于优先级的调度算法，可能会导致低优先级的进程发生“饥饿”（Starvation）现象，后逐步被基于扫描的磁盘调度算法取代。"
        }, {
            "title": "算法实现",
            "text": "在SSTF算法每一次磁头移动之前，会计算距离磁头当前位置最近的访问点作为磁头下一次的运动位置。在计算过程中，一般先将待访问的磁道号进行排序，之后寻找当前磁头在序列中的位置，并判断当前位置前后的两个待访问的磁道号距离磁头的距离，选取距离较近的进行访问。"
        }],
        [{
            "title": "算法特点",
            "text": "扫描（SCAN）磁盘调度算法不仅考虑不到欲访问的磁道与当前磁道间的距离，更优先考虑的是磁头当前的移动方向。这样自里向外地访问，直至再无更外的磁道需要访问时，才将磁道换向为自外向里移动。这时，同样也是每次选择这样的进程来调度，即要访问的磁道在当前位置以内为距离最近者。这样可以有效避免出现“饥饿”现象。"
        }, {
            "title": "算法实现",
            "text": "根据确定的磁头当前移动方向，按照磁道号从大到小或从小到大的顺序一次访问待访问序列中的全部磁道号。一般会先对待访问序列进行排序，并按照方向和顺序依此访问。当磁头移动到大端或小端尽头时，会从该位置向相反方向继续访问。"
        }],
        [{
            "title": "算法特点",
            "text": "循环扫描（CSCAN）磁盘调度算法基本思路与SCAN算法颇为相似，故在此不做相似介绍（详见SCAN算法介绍页面）。但区别在于，SCAN算法中，磁盘自里向外移动到最外侧需要访问的磁道后，再从当前磁道自外向里继续访问。而在CSCAN算法当中规定磁头只做单向寻道移动，例如若规定只能向外寻道移动的情形下，磁头自里向外访问至最外侧磁道后，直接移动回最内侧待访问磁道，并从该磁道再次向外访问；反之亦然，形成循环扫描。SCAN算法和CSCAN算法之间在平均寻道时间上并无明显优劣可分。"
        }, {
            "title": "算法实现",
            "text": "根据确定的磁头当前移动方向，按照磁道号从大到小或从小到大的顺序一次访问待访问序列中的全部磁道号。一般会先对待访问序列进行排序，并按照方向和顺序依此访问。当磁头移动到大端或小端尽头时，会回到另一端（开始端）并继续按照之前的方向顺序访问。"
        }]
    ],
    "pageReplace": [
        [{
            "title": "算法描述",
            "text": "发生缺页时，有些页面在内存中，而其他页面则可能要到10、100或者1000个页面后才会被访问，记录每个页面下一次访问之前操作系统已经访问的页面个数，个数越多说明此页面在长时间内不会被访问，最佳置换算法要求淘汰以后永远不使用、或是在最长（未来）时间内不再被访问的页面。"
        }, {
            "title": "算法特点",
            "text": "此算法只是理论上的算法，由于目前人们还无法预知哪一个页面是未来最长时间内不再被访问的，因此无法将最佳置换算法实现。虽然无法实现，但是我们可以通过最佳置换算法去评价其他算法。最佳置换算法无法实现的核心在于我们不能预知未来哪些页面不会再被访问，但是当我们获得了访问页面的顺序时，此算法就可以被模拟“实现”。"
        }, {
            "title": "算法实现",
            "text": "判断请求的页面是否已经分配在内存中，如果已经存在，则直接进行下一次操作；如果不存在， 遍历已知的请求页面中还没有得到满足的部分，找到内存中已分配的页面下一次请求之前，还有多少个页面请求，找到页面请求个数最大的页面，将其替换出内存。"
        }],
        [{
            "title": "算法描述",
            "text": "淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。"
        }, {
            "title": "算法特点",
            "text": "算法实现简单，但是此算法与进程实际运行的规律不相适应，因为在进程中，有些页面经常被访问，例如含有全局变量，常用函数的页面，先进先出算法并不能保证这些页面不被淘汰。"
        }, {
            "title": "算法实现",
            "text": "将已调入内存的页面按先后顺序连接成为一个队列，并设置一个指针（替换指针），使他指向最老的页面，每次有新的不在内存中的页面请求时，将最老的页面替换。"
        }],
        [{
            "title": "算法描述",
            "text": "此算法选择最近最久未使用的页面予以淘汰，通过赋予在内存中的页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间，当需要淘汰一个页面时，选择未被访问时间最久的页面淘汰。"
        }, {
            "title": "算法特点",
            "text": "此算法需要较多的硬件支持，为了了解一个进程在内存中的各个页面各有多少时间未被进程访问，以及如何快速的知道哪一个页面是最近最久未使用的页面，需要有寄存器和栈两类硬件之一的支持。此算法的实现代价很高。"
        }, {
            "title": "算法实现",
            "text": "页面访问的个数模拟页面访问的时间。从页面进入内存时起时间记为t=0，每到一个新的进程页面请求，此进程时间t增加1，新进程时间记为t=0，通过这种方式记录每一个页面经过的时间。当有不在内存中的页面请求时，选择在内存中经历时间最久的页面进行替换。"
        }]
    ]
}